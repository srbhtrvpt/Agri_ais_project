#include <ros/ros.h>
#include <ros/console.h>
#include <iostream>
#include <pcl/ModelCoefficients.h>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/filters/extract_indices.h>
#include <sensor_msgs/PointCloud2.h>
#include <pcl_ros/point_cloud.h>
#include <pcl_conversions/pcl_conversions.h>


ros::Publisher point_cloud_pub;
ros::Publisher point_cloud_out_pub;

typedef pcl::PointXYZ PointT;
typedef pcl::PointCloud<PointT> PointCloud;


PointCloud::Ptr cloud_in(new PointCloud), cloud_inliers (new PointCloud),
						cloud_outliers (new PointCloud);
sensor_msgs::PointCloud2::Ptr output_ground(new sensor_msgs::PointCloud2), output_plants(new sensor_msgs::PointCloud2); 

pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients);
pcl::PointIndices::Ptr inliers (new pcl::PointIndices);


void callback(const sensor_msgs::PointCloud2ConstPtr &cloud) 
{
coefficients->values.resize (4);
pcl::SACSegmentation<PointT> seg;
seg.setOptimizeCoefficients (true);
seg.setModelType (pcl::SACMODEL_PLANE);
seg.setMethodType (pcl::SAC_RANSAC);
seg.setDistanceThreshold (0.05);
pcl::ExtractIndices<PointT> extract;
 
pcl::fromROSMsg(*cloud, *cloud_in);
seg.setInputCloud (cloud_in);
seg.segment (*inliers, *coefficients);


//std::cout << "size"<<inliers->indices.size();

if (inliers->indices.size () == 0) {
		PCL_ERROR ("Could not estimate a planar model for the given dataset.\n");
		
	}

// Extract inliers
else
{
	extract.setInputCloud (cloud_in);
	extract.setIndices (inliers);
	extract.setNegative (false);			// Extract the inliers
	extract.filter (*cloud_inliers);
    pcl::toROSMsg (*cloud_inliers, *output_ground);		// cloud_inliers contains the plane
    point_cloud_pub.publish(output_ground);
	extract.setNegative (true);				// Extract the outliers
	extract.filter (*cloud_outliers);
    pcl::toROSMsg (*cloud_outliers, *output_plants);
    point_cloud_out_pub.publish(output_plants);
}
}


int main(int argc, char *argv[])
{

    ros::init(argc, argv, "ransac_node");
    ros::NodeHandle nh;
    ros::Subscriber sub = nh.subscribe<sensor_msgs::PointCloud2>("/point_cloud_decay", 10, callback);
    point_cloud_pub = nh.advertise<sensor_msgs::PointCloud2>("point_cloud_ground", 1);
    point_cloud_out_pub = nh.advertise<sensor_msgs::PointCloud2>("point_cloud_plants", 1);

    ros::spin();
}
